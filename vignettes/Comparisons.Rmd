---
title: "Comparisons of computation time"
author: "Benjamin Christoffersen"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Comparisons of computation time}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
options(width = 80)
knitr::opts_chunk$set(collapse = TRUE, comment = "#R>")
```

# TODO: motivate and show features

This vignette shows comparisons in terms of computation with other packages and 
alternative `base` R solutions. Specifially, we will make comparissons with the 
`roll` package and `zoo` package. It should be stressed though that the other 
solutions do additional things than this package does. E.g., there is not 
performed any rank test in the function in this package. We start by showing 
the basic features of the package...

# Comparisons

```{r def_roll_funcs, echo = FALSE, message=FALSE}
#####
# Pure R version of package function
library(SamplerCompare) # for LINPACK `chdd` and `chud`
roll_regress_R <- function(X, y, width){
  n <- nrow(X)
  p <- ncol(X)
  out <- matrix(NA_real_, p, n)

  is_first <- TRUE
  for(i in width:n){
    if(is_first){
      is_first <- FALSE
      qr. <- qr(X[1:width, ])
      R <- qr.R(qr.)

      # Use X^T for the rest
      X <- t(X)

      XtY <- drop(tcrossprod(y[1:width], X[, 1:width]))
    } else {
      x_new <- X[, i]
      x_old <- X[, i - width]

      # update R 
      R <- .Fortran(
        "dchud", R, p, p, x_new, 0., 0L, 0L, 
        0., 0., numeric(p), numeric(p), 
        PACKAGE = "SamplerCompare")[[1]]

      # downdate R
      R <- .Fortran(
        "dchdd", R, p, p, x_old, 0., 0L, 0L, 
        0., 0., numeric(p), numeric(p), integer(1),
        PACKAGE = "SamplerCompare")[[1]]

      # update XtY
      XtY <- XtY + y[i] * x_new - y[i - width] * x_old
    }

    coef. <- .Internal(backsolve(R, XtY, p, TRUE, TRUE))
    coef. <- .Internal(backsolve(R, coef., p, TRUE, FALSE))

    out[, i] <- coef.
  }

  t(out)
}

#####
# simple R version
roll_regress_R_for_loop <- function(X, y, width){
  n <- nrow(X)
  p <- ncol(X)
  out <- matrix(NA_real_, n, p)

  for(i in width:n){
    idx <- (i - width + 1L):i
    out[i, ] <- lm.fit(X[idx, , drop = FALSE], y[idx])$coefficients
  }

  out
}

#####
# zoo version
.zoo_inner <- function(Z) {
  fit <- lm.fit(Z[, -1, drop = FALSE], Z[, 1])
  fit$coefficients
}
library(zoo)
roll_regress_zoo <- function(x, y, width){
  Z <- cbind(y, X)
  rollapply(Z, width, FUN = .zoo_inner,  
            by.column = FALSE,  align = "right", fill = NA_real_)
}

#####
# roll lm
library(roll)
roll_lm_func <- function(x, y ,width)
  roll_lm(X, matrix(y, ncol = 1), wdth, intercept = FALSE)$coefficients[, -1L]

# use one thread as other methods are easily to compute in parallel too
RcppParallel::setThreadOptions(numThreads = 1)

# compile functions
library(compiler)
roll_regress_R          <- cmpfun(roll_regress_R)
roll_regress_R_for_loop <- cmpfun(roll_regress_R_for_loop)
.zoo_inner              <- cmpfun(.zoo_inner)
roll_regress_zoo        <- cmpfun(roll_regress_zoo)
roll_lm_func            <- cmpfun(roll_lm_func)
```

We start by Simulating the data

```{r sim_data}
set.seed(101)
n <- 10000
p <- 6
wdth = 50
X <- matrix(rnorm(p * n), n, p)
y <- drop(X %*% runif(p)) + rnorm(n)
df <- data.frame(y, X)
frm <- eval(parse(text = paste0(
  "formula(y ~ -1 + ", paste0("X", 1:p, collapse = " + "), ")")))
```

Then we check that the functions give the same (the function definitions are at
the end of this document)

```{r roll_gives_same}
library(rollRegres)
all.equal(roll_regress_R(X, y, wdth), roll_regres.fit(X, y, wdth), 
          check.attributes = FALSE)
all.equal(roll_regress_R(X, y, wdth), roll_regres(frm, df, wdth), 
          check.attributes = FALSE)
all.equal(roll_regress_R(X, y, wdth), roll_regress_zoo(X, y, wdth), 
          check.attributes = FALSE)
all.equal(roll_regress_R(X, y, wdth), roll_regress_R_for_loop(X, y, wdth), 
          check.attributes = FALSE)
all.equal(roll_regress_R(X, y, wdth), roll_lm_func(X, y, wdth), 
          check.attributes = FALSE)
```

and here then we compare the computation time

```{r benchmark_roll}
microbenchmark::microbenchmark(
  roll_regress            = roll_regres.fit(X, y, wdth),
  # this will be slower due to call to `model.matrix` and `model.frame`
  roll_regress_df         = roll_regres(frm, df, wdth),
  roll_regress_R          = roll_regress_R(X, y, wdth),
  roll_regress_zoo        = roll_regress_zoo(X, y, wdth),
  roll_regress_R_for_loop = roll_regress_R_for_loop(X, y, wdth),
  roll_lm = roll_lm_func(X, y, wdth),
  times = 5)
```

# Session info

```{r ses_info}
sessionInfo()
```

# Function definitions

Here are the function definitions

```{r def_roll_funcs, eval = FALSE}
```
